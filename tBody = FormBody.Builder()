[1mdiff --git a/app/build.gradle.kts b/app/build.gradle.kts[m
[1mindex ceec042..1ab8792 100644[m
[1m--- a/app/build.gradle.kts[m
[1m+++ b/app/build.gradle.kts[m
[36m@@ -1,4 +1,3 @@[m
[31m-[m
 import java.io.FileInputStream[m
 import java.util.Properties[m
 [m
[36m@@ -8,23 +7,21 @@[m [mplugins {[m
     alias(libs.plugins.jetbrainsKotlinAndroid)[m
     alias(libs.plugins.ktfmt)[m
     alias(libs.plugins.gms)[m
[31m-[m
 }[m
 [m
 android {[m
     namespace = "com.github.se.orator"[m
     compileSdk = 34[m
 [m
[31m-[m
[31m-    // Load the API key from local.properties[m
[32m+[m[32m    // Load API keys from local.properties[m
     val localProperties = Properties()[m
     val localPropertiesFile = rootProject.file("local.properties")[m
     if (localPropertiesFile.exists()) {[m
         localProperties.load(FileInputStream(localPropertiesFile))[m
     }[m
 [m
[31m-    val mapsApiKey: String = localProperties.getProperty("MAPS_API_KEY") ?: ""[m
[31m-[m
[32m+[m[32m    val symblAppId: String = localProperties.getProperty("SYMBL_APP_ID") ?: ""[m
[32m+[m[32m    val symblAppSecret: String = localProperties.getProperty("SYMBL_APP_SECRET") ?: ""[m
 [m
     defaultConfig {[m
         applicationId = "com.github.se.orator"[m
[36m@@ -37,7 +34,10 @@[m [mandroid {[m
         vectorDrawables {[m
             useSupportLibrary = true[m
         }[m
[31m-        manifestPlaceholders["MAPS_API_KEY"] = mapsApiKey[m
[32m+[m
[32m+[m[32m        // Pass API keys to the manifest[m
[32m+[m[32m        manifestPlaceholders["SYMBL_APP_ID"] = symblAppId[m
[32m+[m[32m        manifestPlaceholders["SYMBL_APP_SECRET"] = symblAppSecret[m
     }[m
 [m
     buildTypes {[m
[36m@@ -52,19 +52,25 @@[m [mandroid {[m
             enableAndroidTestCoverage = true[m
         }[m
     }[m
[32m+[m
     compileOptions {[m
         sourceCompatibility = JavaVersion.VERSION_11[m
         targetCompatibility = JavaVersion.VERSION_11[m
     }[m
[32m+[m
     kotlinOptions {[m
         jvmTarget = "11"[m
     }[m
[32m+[m
     buildFeatures {[m
         compose = true[m
[32m+[m[32m        buildConfig = true[m
     }[m
[32m+[m
     composeOptions {[m
         kotlinCompilerExtensionVersion = "1.5.1"[m
     }[m
[32m+[m
     packaging {[m
         resources {[m
             excludes += "/META-INF/{AL2.0,LGPL2.1}"[m
[36m@@ -82,7 +88,6 @@[m [mandroid {[m
     testOptions {[m
         unitTests {[m
             isIncludeAndroidResources = true[m
[31m-[m
             isReturnDefaultValues = true[m
         }[m
         packagingOptions {[m
[36m@@ -92,23 +97,9 @@[m [mandroid {[m
         }[m
     }[m
 [m
[31m-[m
[31m-    buildFeatures {[m
[31m-        compose = true[m
[31m-        buildConfig = true[m
[31m-    }[m
[31m-[m
[31m-    kotlinOptions {[m
[31m-        jvmTarget = "11"[m
[31m-    }[m
[31m-[m
[31m-    // Robolectric needs to be run only in debug. But its tests are placed in the shared source set (test)[m
[31m-    // The next lines transfers the src/test/* from shared to the testDebug one[m
[31m-    //[m
[31m-    // This prevent errors from occurring during unit tests[m
[32m+[m[32m    // Robolectric testing setup[m
     sourceSets.getByName("testDebug") {[m
         val test = sourceSets.getByName("test")[m
[31m-[m
         java.setSrcDirs(test.java.srcDirs)[m
         res.setSrcDirs(test.res.srcDirs)[m
         resources.setSrcDirs(test.resources.srcDirs)[m
[36m@@ -121,10 +112,8 @@[m [mandroid {[m
     }[m
 }[m
 [m
[31m-[m
 dependencies {[m
[31m-[m
[31m-    // Core[m
[32m+[m[32m    // Core Libraries[m
     implementation(libs.core.ktx)[m
     implementation(libs.androidx.core.ktx)[m
     implementation(libs.androidx.lifecycle.runtime.ktx)[m
[36m@@ -147,28 +136,19 @@[m [mdependencies {[m
     debugImplementation(libs.androidx.ui.test.manifest)[m
     implementation(libs.material)[m
 [m
[31m-[m
[31m-    // Navigation[m
[31m-    implementation(libs.androidx.navigation.compose)[m
[31m-    implementation(libs.androidx.navigation.fragment.ktx)[m
[31m-    implementation(libs.androidx.navigation.ui.ktx)[m
[31m-[m
[31m-    // Google Service and Maps[m
[32m+[m[32m    // Google Maps and Services[m
     implementation(libs.play.services.maps)[m
     implementation(libs.maps.compose)[m
     implementation(libs.maps.compose.utils)[m
     implementation(libs.play.services.auth)[m
 [m
     // Firebase[m
[31m-[m
     implementation(platform(libs.firebase.bom))[m
     implementation(libs.firebase.database.ktx)[m
     implementation(libs.firebase.firestore)[m
     implementation(libs.firebase.ui.auth)[m
     implementation(libs.firebase.auth.ktx)[m
     implementation(libs.firebase.auth)[m
[31m-[m
[31m-    // Firebase storage[m
     implementation(libs.firebase.storage)[m
     implementation(libs.firebase.appcheck)[m
 [m
[36m@@ -176,38 +156,54 @@[m [mdependencies {[m
     implementation(libs.coil.compose)[m
 [m
     // Networking with OkHttp[m
[31m-    implementation(libs.okhttp)[m
[32m+[m[32m    // Replace existing okhttp dependency with the specific version needed[m
[32m+[m[32m    implementation("com.squareup.okhttp3:okhttp:4.12.0")[m
[32m+[m
[32m+[m[32m    // Symbl.ai dependencies[m
[32m+[m[32m    implementation("org.java-websocket:Java-WebSocket:1.5.1")[m
[32m+[m[32m    implementation("ai.symbl:android.extension:0.0.2")[m
[32m+[m
[32m+[m[32m    // Gson for JSON parsing[m
[32m+[m[32m    implementation("com.google.code.gson:gson:2.10.1")[m
[32m+[m
[32m+[m[32m    // Compose Material Icons for Mic and MicOff[m
[32m+[m[32m    implementation("androidx.compose.material:material-icons-extended:1.0.5")[m
 [m
[31m-    // Testing Unit[m
[32m+[m[32m    // Testing Libraries[m
     testImplementation(libs.junit)[m
     androidTestImplementation(libs.mockk)[m
     androidTestImplementation(libs.mockk.android)[m
     androidTestImplementation(libs.mockk.agent)[m
     testImplementation(libs.json)[m
 [m
[31m-    // Test UI[m
[32m+[m[32m    // UI Testing Libraries[m
     androidTestImplementation(libs.androidx.junit)[m
     androidTestImplementation(libs.androidx.espresso.core)[m
     androidTestImplementation(libs.androidx.espresso.intents)[m
     androidTestImplementation(libs.androidx.ui.test.junit4)[m
     androidTestImplementation(platform(libs.androidx.compose.bom))[m
[32m+[m
[32m+[m[32m    // Mockito for Unit Testing[m
     testImplementation(libs.mockito.core)[m
     testImplementation(libs.mockito.inline)[m
     testImplementation(libs.mockito.kotlin)[m
     androidTestImplementation(libs.mockito.android)[m
     androidTestImplementation(libs.mockito.kotlin)[m
[32m+[m
[32m+[m[32m    // Robolectric[m
     testImplementation(libs.robolectric)[m
[32m+[m
[32m+[m[32m    // Kaspresso[m
     androidTestImplementation(libs.kaspresso)[m
     androidTestImplementation(libs.kaspresso.allure.support)[m
     androidTestImplementation(libs.kaspresso.compose.support)[m
 [m
[32m+[m[32m    // Coroutines Testing[m
     testImplementation(libs.kotlinx.coroutines.test)[m
[31m-[m
 }[m
 [m
[31m-[m
 tasks.withType<Test> {[m
[31m-    // Configure Jacoco for each tests[m
[32m+[m[32m    // Configure Jacoco for each test[m
     configure<JacocoTaskExtension> {[m
         isIncludeNoLocationClasses = true[m
         excludes = listOf("jdk.internal.*")[m
[36m@@ -243,8 +239,3 @@[m [mtasks.register("jacocoTestReport", JacocoReport::class) {[m
         include("outputs/code_coverage/debugAndroidTest/connected/*/coverage.ec")[m
     })[m
 }[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[1mdiff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml[m
[1mindex 3f5b678..703482e 100644[m
[1m--- a/app/src/main/AndroidManifest.xml[m
[1m+++ b/app/src/main/AndroidManifest.xml[m
[36m@@ -1,14 +1,25 @@[m
[32m+[m[32m<!-- AndroidManifest.xml -->[m
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"[m
[32m+[m[32m    package="com.github.se.orator"[m
     xmlns:tools="http://schemas.android.com/tools">[m
 [m
[31m-    <!-- Camera permission is still required -->[m
[31m-    <uses-permission android:name="android.permission.CAMERA"/>[m
[32m+[m[32m    <!-- Permissions -->[m
[32m+[m[32m    <uses-permission android:name="android.permission.RECORD_AUDIO"/>[m
[32m+[m[32m    <uses-permission android:name="android.permission.INTERNET"/>[m
[32m+[m[32m    <!-- Remove if not needed -->[m
[32m+[m[32m    <!-- <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/> -->[m
[32m+[m[32m    <!-- <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/> -->[m
 [m
[31m-    <!-- Scoped storage or more granular media access for Android 10 and above -->[m
[31m-    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"[m
[31m-        tools:targetApi="33"/>[m
[31m-    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"[m
[31m-        tools:targetApi="33"/>[m
[32m+[m[32m    <!-- Optional: Camera and Media Permissions -->[m
[32m+[m[32m    <!-- Remove if not using camera or media storage -->[m
[32m+[m[32m    <!--[m
[32m+[m[32m    <uses-feature[m
[32m+[m[32m        android:name="android.hardware.camera"[m
[32m+[m[32m        android:required="false" />[m
[32m+[m[32m    <uses-permission android:name="android.permission.CAMERA"/>[m
[32m+[m[32m    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" tools:targetApi="33"/>[m
[32m+[m[32m    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" tools:targetApi="33"/>[m
[32m+[m[32m    -->[m
 [m
     <application[m
         android:allowBackup="true"[m
[36m@@ -20,16 +31,23 @@[m
         android:supportsRtl="true"[m
         android:theme="@style/Theme.Project"[m
         tools:targetApi="31">[m
[32m+[m
[32m+[m[32m        <!-- Symbl.ai Credentials -->[m
[32m+[m[32m        <meta-data[m
[32m+[m[32m            android:name="SYMBL_APP_ID"[m
[32m+[m[32m            android:value="${SYMBL_APP_ID}" />[m
[32m+[m[32m        <meta-data[m
[32m+[m[32m            android:name="SYMBL_APP_SECRET"[m
[32m+[m[32m            android:value="${SYMBL_APP_SECRET}" />[m
[32m+[m
         <activity[m
             android:name=".MainActivity"[m
             android:exported="true"[m
             android:theme="@style/Theme.Project">[m
             <intent-filter>[m
                 <action android:name="android.intent.action.MAIN" />[m
[31m-[m
                 <category android:name="android.intent.category.LAUNCHER" />[m
             </intent-filter>[m
         </activity>[m
     </application>[m
[31m-[m
 </manifest>[m
[1mdiff --git a/app/src/main/java/com/github/se/orator/model/symblAi/SymblApiClient.kt b/app/src/main/java/com/github/se/orator/model/symblAi/SymblApiClient.kt[m
[1mnew file mode 100644[m
[1mindex 0000000..4ef29b3[m
[1m--- /dev/null[m
[1m+++ b/app/src/main/java/com/github/se/orator/model/symblAi/SymblApiClient.kt[m
[36m@@ -0,0 +1,362 @@[m
[32m+[m[32mpackage com.github.se.orator.model.symblAi[m
[32m+[m
[32m+[m[32m// SymblApiClient.kt[m
[32m+[m
[32m+[m[32mimport android.content.Context[m
[32m+[m[32mimport android.content.pm.PackageManager[m
[32m+[m[32mimport android.util.Log[m
[32m+[m[32mimport okhttp3.*[m
[32m+[m[32mimport okhttp3.MediaType.Companion.toMediaTypeOrNull[m
[32m+[m[32mimport org.json.JSONObject[m
[32m+[m[32mimport java.io.File[m
[32m+[m[32mimport java.io.IOException[m
[32m+[m
[32m+[m[32mclass SymblApiClient(private val context: Context) {[m
[32m+[m
[32m+[m[32m    // Variables to hold Symbl.ai credentials[m
[32m+[m[32m    private var symblAppId: String? = null[m
[32m+[m[32m    private var symblAppSecret: String? = null[m
[32m+[m
[32m+[m[32m    private var accessToken: String? = null[m
[32m+[m
[32m+[m[32m    // Variables to store results[m
[32m+[m[32m    private var transcribedText: String = ""[m
[32m+[m[32m    private var sentimentResult: String = ""[m
[32m+[m[32m    private var fillersResult: String = ""[m
[32m+[m[32m    private var insightsResult: String = ""[m
[32m+[m
[32m+[m[32m    interface SymblListener {[m
[32m+[m[32m        fun onProcessingComplete([m
[32m+[m[32m            transcribedText: String,[m
[32m+[m[32m            sentimentResult: String,[m
[32m+[m[32m            fillersResult: String[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        fun onError(message: String)[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    private var listener: SymblListener? = null[m
[32m+[m
[32m+[m[32m    fun setListener(symblListener: SymblListener) {[m
[32m+[m[32m        listener = symblListener[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    init {[m
[32m+[m[32m        // Retrieve Symbl.ai credentials from the manifest[m
[32m+[m[32m        val appInfo = context.packageManager.getApplicationInfo([m
[32m+[m[32m            context.packageName,[m
[32m+[m[32m            PackageManager.GET_META_DATA[m
[32m+[m[32m        )[m
[32m+[m[32m        symblAppId = appInfo.metaData.getString("SYMBL_APP_ID")[m
[32m+[m[32m        symblAppSecret = appInfo.metaData.getString("SYMBL_APP_SECRET")[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Function to get access token[m
[32m+[m[32m    fun getAccessToken(onResult: (String?) -> Unit) {[m
[32m+[m[32m        if (symblAppId.isNullOrEmpty() || symblAppSecret.isNullOrEmpty()) {[m
[32m+[m[32m            onResult(null)[m
[32m+[m[32m            listener?.onError("Symbl.ai credentials are missing.")[m
[32m+[m[32m            return[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        val client = OkHttpClient()[m
[32m+[m
[32m+[m[32m        val url = "https://api.symbl.ai/oauth2/token:generate"[m
[32m+[m
[32m+[m[32m        val requestBody = FormBody.Builder()[m
[32m+[m[32m            .add("type", "application")[m
[32m+[m[32m            .add("appId", symblAppId!!)[m
[32m+[m[32m            .add("appSecret", symblAppSecret!!)[m
[32m+[m[32m            .build()[m
[32m+[m
[32m+[m[32m        val request = Request.Builder()[m
[32m+[m[32m            .url(url)[m
[32m+[m[32m            .post(requestBody)[m
[32m+[m[32m            .build()[m
[32m+[m
[32m+[m[32m        client.newCall(request).enqueue(object : Callback {[m
[32m+[m[32m            override fun onFailure(call: Call, e: IOException) {[m
[32m+[m[32m                e.printStackTrace()[m
[32m+[m[32m                listener?.onError("Failed to get access token: ${e.message}")[m
[32m+[m[32m                onResult(null)[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            override fun onResponse(call: Call, response: Response) {[m
[32m+[m[32m                val responseData = response.body?.string()[m
[32m+[m[32m                Log.d("Access Token Response", responseData ?: "No Response")[m
[32m+[m[32m                if (response.isSuccessful && responseData != null) {[m
[32m+[m[32m                    val json = JSONObject(responseData)[m
[32m+[m[32m                    accessToken = json.getString("accessToken")[m
[32m+[m[32m                    onResult(accessToken)[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    listener?.onError("Failed to get access token: ${response.message}")[m
[32m+[m[32m                    Log.e("Access Token Error", "Response: $responseData")[m
[32m+[m[32m                    onResult(null)[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        })[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Function to send the audio file to Symbl API[m
[32m+[m[32m    fun sendAudioToSymbl(audioFile: File) {[m
[32m+[m[32m        getAccessToken { token ->[m
[32m+[m[32m            if (token != null) {[m
[32m+[m[32m                val client = OkHttpClient()[m
[32m+[m
[32m+[m[32m                // Specify the correct media type for the audio file[m
[32m+[m[32m                val mediaType = "audio/wav".toMediaTypeOrNull() // For WAV files[m
[32m+[m[32m                val requestBody = RequestBody.create(mediaType, audioFile)[m
[32m+[m
[32m+[m[32m                // Corrected API request URL with 'filler_words'[m
[32m+[m[32m                val request = Request.Builder()[m
[32m+[m[32m                    .url("https://api.symbl.ai/v1/process/audio?enableAllInsights=true&insightTypes=filler_words")[m
[32m+[m[32m                    .addHeader("Authorization", "Bearer $token")[m
[32m+[m[32m                    .post(requestBody)[m
[32m+[m[32m                    .build()[m
[32m+[m
[32m+[m[32m                client.newCall(request).enqueue(object : Callback {[m
[32m+[m[32m                    override fun onFailure(call: Call, e: IOException) {[m
[32m+[m[32m                        e.printStackTrace()[m
[32m+[m[32m                        listener?.onError("Request failed: ${e.message}")[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    override fun onResponse(call: Call, response: Response) {[m
[32m+[m[32m                        val responseData = response.body?.string() ?: "No Response"[m
[32m+[m[32m                        Log.d("Symbl Response", responseData)[m
[32m+[m[32m                        if (response.isSuccessful) {[m
[32m+[m[32m                            val jsonObject = JSONObject(responseData)[m
[32m+[m[32m                            if (jsonObject.has("conversationId")) {[m
[32m+[m[32m                                val conversationId = jsonObject.getString("conversationId")[m
[32m+[m[32m                                // Start polling for messages[m
[32m+[m[32m                                pollForMessages(conversationId, token)[m
[32m+[m[32m                                // Start polling for filler words[m
[32m+[m[32m                                pollForFillers(conversationId, token)[m
[32m+[m[32m                            } else {[m
[32m+[m[32m                                listener?.onError("No valid conversationId found. Response: $responseData")[m
[32m+[m[32m                                Log.e("Symbl Error", "No conversationId: $responseData")[m
[32m+[m[32m                            }[m
[32m+[m[32m                        } else {[m
[32m+[m[32m                            listener?.onError("Request failed: $responseData")[m
[32m+[m[32m                            Log.e("Symbl Error", "Request failed: $responseData")[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                })[m
[32m+[m[32m            } else {[m
[32m+[m[32m                listener?.onError("Cannot proceed without access token.")[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Polling function to check for message availability[m
[32m+[m[32m    private fun pollForMessages(conversationId: String, accessToken: String, attempts: Int = 0) {[m
[32m+[m[32m        val maxAttempts = 10[m
[32m+[m[32m        val delayMillis = 2000L // Wait 2 seconds between attempts[m
[32m+[m
[32m+[m[32m        val client = OkHttpClient()[m
[32m+[m
[32m+[m[32m        val request = Request.Builder()[m
[32m+[m[32m            .url("https://api.symbl.ai/v1/conversations/$conversationId/messages?sentiment=true&enableAllInsights=true")[m
[32m+[m[32m            .addHeader("Authorization", "Bearer $accessToken")[m
[32m+[m[32m            .get()[m
[32m+[m[32m            .build()[m
[32m+[m
[32m+[m[32m        client.newCall(request).enqueue(object : Callback {[m
[32m+[m[32m            override fun onFailure(call: Call, e: IOException) {[m
[32m+[m[32m                e.printStackTrace()[m
[32m+[m[32m                listener?.onError("Polling failed: ${e.message}")[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            override fun onResponse(call: Call, response: Response) {[m
[32m+[m[32m                val responseData = response.body?.string() ?: ""[m
[32m+[m[32m                Log.d("Polling Response", responseData)[m
[32m+[m
[32m+[m[32m                if (response.isSuccessful && responseData.isNotEmpty()) {[m
[32m+[m[32m                    val sentimentJson = JSONObject(responseData)[m
[32m+[m[32m                    val messagesArray = sentimentJson.getJSONArray("messages")[m
[32m+[m
[32m+[m[32m                    if (messagesArray.length() > 0) {[m
[32m+[m[32m                        // Messages are available, proceed to parse them[m
[32m+[m[32m                        parseSentimentResponse(sentimentJson)[m
[32m+[m[32m                    } else if (attempts < maxAttempts) {[m
[32m+[m[32m                        // Messages not yet available, wait and try again[m
[32m+[m[32m                        Log.d("Polling", "Messages not available yet. Attempt ${attempts + 1}")[m
[32m+[m[32m                        Thread.sleep(delayMillis)[m
[32m+[m[32m                        pollForMessages(conversationId, accessToken, attempts + 1)[m
[32m+[m[32m                    } else {[m
[32m+[m[32m                        // Max attempts reached, handle accordingly[m
[32m+[m[32m                        listener?.onError("No messages found after polling.")[m
[32m+[m[32m                    }[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    listener?.onError("Polling failed: ${response.message}")[m
[32m+[m[32m                    Log.e("Polling Error", "Response: $responseData")[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        })[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    private fun parseSentimentResponse(sentimentJson: JSONObject) {[m
[32m+[m[32m        try {[m
[32m+[m[32m            val messagesArray = sentimentJson.getJSONArray("messages")[m
[32m+[m[32m            if (messagesArray.length() > 0) {[m
[32m+[m[32m                val textBuilder = StringBuilder()[m
[32m+[m[32m                val sentimentBuilder = StringBuilder()[m
[32m+[m[32m                val insightsBuilder = StringBuilder()[m
[32m+[m
[32m+[m[32m                for (i in 0 until messagesArray.length()) {[m
[32m+[m[32m                    val messageObject = messagesArray.getJSONObject(i)[m
[32m+[m[32m                    val messageText = messageObject.getString("text")[m
[32m+[m
[32m+[m[32m                    // Log insights to verify if disfluencies are being returned[m
[32m+[m[32m                    val insights = messageObject.optJSONArray("insights")[m
[32m+[m[32m                    Log.d("Message Insights", insights?.toString() ?: "No insights")[m
[32m+[m
[32m+[m[32m                    // Collect disfluencies (e.g., filler words) from insights[m
[32m+[m[32m                    val disfluencies = StringBuilder()[m
[32m+[m[32m                    insights?.let {[m
[32m+[m[32m                        for (j in 0 until it.length()) {[m
[32m+[m[32m                            val insightObject = it.getJSONObject(j)[m
[32m+[m[32m                            val insightType = insightObject.getString("type")[m
[32m+[m[32m                            Log.d("Insight Type", insightType) // Log insight type[m
[32m+[m[32m                            insightsBuilder.append("Insight: ${insightType}\n") // Collect insights[m
[32m+[m[32m                            if (insightType == "filler_word") { // Use the correct insight type[m
[32m+[m[32m                                val fillerWord = insightObject.getString("text")[m
[32m+[m[32m                                disfluencies.append("[$fillerWord] ")  // Add disfluency with brackets[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    // Append the disfluencies before the transcribed message[m
[32m+[m[32m                    textBuilder.append("You said: $disfluencies$messageText\n")[m
[32m+[m
[32m+[m[32m                    val sentiment = messageObject.optJSONObject("sentiment")[m
[32m+[m[32m                    if (sentiment != null) {[m
[32m+[m[32m                        val polarity = sentiment.getString("suggested")[m
[32m+[m[32m                        val score = sentiment.getJSONObject("polarity").getDouble("score")[m
[32m+[m[32m                        sentimentBuilder.append("Sentiment: $polarity (Score: $score)\n")[m
[32m+[m[32m                    } else {[m
[32m+[m[32m                        sentimentBuilder.append("No sentiment data available.\n")[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                // Store the results in class variables[m
[32m+[m[32m                transcribedText = textBuilder.toString()[m
[32m+[m[32m                sentimentResult = sentimentBuilder.toString()[m
[32m+[m[32m                insightsResult = insightsBuilder.toString()[m
[32m+[m
[32m+[m[32m                listener?.onProcessingComplete([m
[32m+[m[32m                    transcribedText = transcribedText,[m
[32m+[m[32m                    sentimentResult = sentimentResult,[m
[32m+[m[32m                    fillersResult = fillersResult // Fillers are handled separately[m
[32m+[m[32m                )[m
[32m+[m[32m            } else {[m
[32m+[m[32m                listener?.onError("No messages found in the response.")[m
[32m+[m[32m            }[m
[32m+[m[32m        } catch (e: Exception) {[m
[32m+[m[32m            listener?.onError("Error parsing response: ${e.message}")[m
[32m+[m[32m            Log.e("Parsing Error", e.message ?: "Unknown error")[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Polling function to check for filler words availability[m
[32m+[m[32m    private fun pollForFillers(conversationId: String, accessToken: String, attempts: Int = 0) {[m
[32m+[m[32m        val maxAttempts = 10[m
[32m+[m[32m        val delayMillis = 2000L // Wait 2 seconds between attempts[m
[32m+[m
[32m+[m[32m        val client = OkHttpClient()[m
[32m+[m
[32m+[m[32m        val request = Request.Builder()[m
[32m+[m[32m            .url("https://api.symbl.ai/v1/conversations/$conversationId/insights?insightTypes=filler_words")[m
[32m+[m[32m            .addHeader("Authorization", "Bearer $accessToken")[m
[32m+[m[32m            .get()[m
[32m+[m[32m            .build()[m
[32m+[m
[32m+[m[32m        client.newCall(request).enqueue(object : Callback {[m
[32m+[m[32m            override fun onFailure(call: Call, e: IOException) {[m
[32m+[m[32m                e.printStackTrace()[m
[32m+[m[32m                listener?.onError("Filler words polling failed: ${e.message}")[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            override fun onResponse(call: Call, response: Response) {[m
[32m+[m[32m                val fillerData = response.body?.string() ?: ""[m
[32m+[m[32m                Log.d("Filler Words Polling Response", fillerData)[m
[32m+[m
[32m+[m[32m                if (response.isSuccessful && fillerData.isNotEmpty()) {[m
[32m+[m[32m                    val fillerJson = JSONObject(fillerData)[m
[32m+[m[32m                    val insightsArray = fillerJson.getJSONArray("insights")[m
[32m+[m
[32m+[m[32m                    if (insightsArray.length() > 0) {[m
[32m+[m[32m                        // Fillers are available, proceed to parse them[m
[32m+[m[32m                        parseFillerResponse(fillerJson)[m
[32m+[m[32m                    } else if (attempts < maxAttempts) {[m
[32m+[m[32m                        // Fillers not yet available, wait and try again[m
[32m+[m[32m                        Log.d("Filler Polling", "Fillers not available yet. Attempt ${attempts + 1}")[m
[32m+[m[32m                        Thread.sleep(delayMillis)[m
[32m+[m[32m         